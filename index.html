<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL</title>
    <script>
        const vertexShader = `
            attribute vec2 aCoords;
            uniform vec2 uTranslation;
            void main() {
                float x = -1.0 + 2.0*((aCoords.x + uTranslation.x) / 600.0);
                float y = 1.0 - 2.0*((aCoords.y + uTranslation.y) / 600.0);
                gl_Position = vec4(x, y , 0.0, 1.0);
            }
        `;
        const fragmetnShader = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0,0.0,0.0,1.0);
            }
        `;
        let g;
        let aCoordsLoc;
        let uTranslationLoc;
        let shapeDataBuffer;
    
        function createProgram(g, vShaderSrc, fShaderSrc) {
            let vShader = g.createShader(g.VERTEX_SHADER);
            g.shaderSource(vShader,vShaderSrc);
            g.compileShader(vShader);
            if ( ! g.getShaderParameter(vShader, g.COMPILE_STATUS) ) {
                throw "Error in vertex shader:  " + g.getShaderInfoLog(vShader);
            }

            let fShader = g.createShader(g.FRAGMENT_SHADER);
            g.shaderSource(fShader,fShaderSrc);
            g.compileShader(fShader);
            if ( ! g.getShaderParameter(fShader, g.COMPILE_STATUS) ) {
                throw "Error in fragment shader:  " + g.getShaderInfoLog(fShader);
            }

            let prog = g.createProgram();
            g.attachShader(prog, vShader);
            g.attachShader(prog, fShader);
            g.linkProgram(prog);

            return prog;
        }

        // gets the points that were clicked and draws object at those points
        function draw(xClick, yClick) {
            g.uniform2f(uTranslationLoc, xClick, yClick)
            g.bindBuffer(g.ARRAY_BUFFER, shapeDataBuffer);
            g.vertexAttribPointer(aCoordsLoc, 2, g.FLOAT, false, 0, 0);
            g.drawArrays(g.TRIANGLE_FAN, 0, 32);
        }

        function createBuffer() {
            let coords = new Float32Array(64);
            let k = 0;  // index into the coords array
            for (let i = 0; i < 32; i++) {
                let angle = i/32 * 2*Math.PI;
                coords[k++] = 2*Math.cos(angle);  // x-coord of vertex
                coords[k++] = 2*Math.sin(angle);  // y-coord of vertex
            }
            shapeDataBuffer = g.createBuffer();
            g.bindBuffer(g.ARRAY_BUFFER, shapeDataBuffer);
            g.bufferData(g.ARRAY_BUFFER, coords, g.STATIC_DRAW);
        }

        function initGL() {
            let prog = createProgram(g,vertexShader,fragmetnShader);
            g.useProgram(prog)
            aCoordsLoc = g.getAttribLocation(prog,"aCoords");
            uTranslationLoc = g.getUniformLocation(prog,"uTranslation");
            g.enableVertexAttribArray(aCoordsLoc);
            createBuffer();
            g.clearColor(0.1,0.2,0.2,1);
            g.clear(g.COLOR_BUFFER_BIT);
        }

        function init() {
            let canvas = document.getElementById("myCanvas");
            let options = {  // no need for alpha channel or depth buffer in this program,
                         // but we need to preserve the image in the drawingBuffer
            alpha: false,
            depth: false,
            preserveDrawingBuffer: true
        };
            g = canvas.getContext("webgl", {preserveDrawingBuffer: true});
            initGL();

            canvas.addEventListener("click", function(event) {   
                let env = canvas.getBoundingClientRect();
                let x = event.clientX - env.left;
                let y = event.clientY - env.top;
                draw(x, y);
            }, false);
            
        }
    </script>  
</head>  
<body onload="init()">
    <h1>Canvas</h1>
    <canvas width="600" height="600" id="myCanvas">
    </canvas>
</body>
</html>